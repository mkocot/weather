<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="uPlot.min.css">
  <meta http-equiv="refresh" content="300" />
  <title>Weather station v0.0.2</title>
</head>

<body>

  <script src="uPlot.iife.js"></script>

  <script type="text/javascript">
    var data = {};
    var sensorid = "e09806259a66";
    var sensorid2 = "24a1603048ba";
    var sensoridOut = "ec62609d4998";

    function absolute_humidity(t, p, h) {
      if (!t || !p || !h) {
        return null;
      }
      // https://planetcalc.com/2167/
      Rw = 461.52 // J/(kgK)
      ew_t = 6.112*Math.exp((17.62*t)/(243.12+t))
      f_p = 1.0016 + (3.15E-6*p)-(0.074/p)
      A = h * f_p * ew_t
      B = (Rw * (t+ 273.15))
      return A/B
    }
    function dew_point(t, h) {
      if (!t || !h) {
        return null;
      }
      // https://en.wikipedia.org/wiki/Dew_point
      a = 17.625
      b = 243.04
      F = a*t/(b + t) + Math.log(h)
      return b*F / (a - F)
    }
    function zip(arrays) {
      // https://stackoverflow.com/questions/4856717/javascript-equivalent-of-pythons-zip-function
      return arrays[0].map(function(_,i){
        return arrays.map(function(array){return array[i]})
      });
    }
    function create_timepoints(_data) {
      // check for 
      var timepoints = new Array(_data.clock.count);
      for (i = 0; i < _data.clock.count; ++i) {
        timepoints[i] = (_data.clock.start + _data.clock.tick * i);
      }
      return timepoints;
    }
    var xmlhttp = new XMLHttpRequest();
    var url = "data.json";
    xmlhttp.onreadystatechange = function() {
      if (!(this.readyState == 4 && this.status == 200)) {
	      return;
      }
      data = JSON.parse(this.responseText);
      console.log("Data fetched");
      var augmented = [];
      var width = window.innerWidth * 0.9 || 800;
      var timepoints = create_timepoints(data);
      let default_fetch = (key) => {
      return () => [timepoints,
	      data[sensorid][key],
	      data[sensorid2][key],
	      data[sensoridOut][key]];
      };
      let graphs = [
        {
          title: "Temp [°C]",
          fill: "rgba(200, 0, 0, 0.3)",
          unit: "°C",
          stroke: "red",
          fetch: default_fetch("temp"),
          resolution: 1
        },
        //{
        //  title: "Dew point [°C]",
        //  fill: "rgba(255, 128, 128, 0.3)",
        //  unit: "°C",
        //  stroke: "green",
        //  fetch: () => {
        //    dewpointer = (x) => zip([data[x]["temp"], data[x]["hum"]]).map((xx) => dew_point(xx[0], xx[1] * 0.01));
        //    return [timepoints, dewpointer(sensorid), dewpointer(sensorid2), dewpointer(sensoridOut)];
        //  },
        //  customize: (o) => { o.series[3].show = true; }
        //},
        {
          title: "Humidity [%]",
          fill: "rgba(0, 0, 255, 0.3)",
          unit: "%",
          stroke: "blue",
          fetch: default_fetch("hum")
        },
        {
          title: "Absolute Humidity [g/m³]",
          fill: "rgba(0, 128, 128, 0.3)",
          unit: "g/m³",
          stroke: "rgb(0, 255, 255)",
          fetch: () => {
	          mapper = (x) => 1000 * absolute_humidity(x[0], x[1], x[2]);
      	    humidifier = (x) => zip([data[x]["temp"], data[x]["pres"], data[x]["hum"]]).map(mapper);
	          return [timepoints, humidifier(sensorid), humidifier(sensorid2), humidifier(sensoridOut)];
	        }
        },
        {
          title: "Pressure [hPa]",
          fill: "rgba(0, 255, 255, 0.3)",
          unit: "hPa",
          stroke: "purple",
          fetch: default_fetch("pres")
        },
        {
          title: "Bat [V]",
          fill: "rgba(128, 64, 64, 0.3)",
          unit: "V",
          stroke: "gray",
	  resolution: 2,
          fetch: default_fetch("volt"),
          customize: (o) => {
            o.series.splice(3, 1);
	        }
        }//,
        //{
        //  title: "Air Quality Index",
        //  fill: "rgba(64, 64, 64, 0.3)",
        //  unit: "",
        //  stroke: "navy",
        //  fetch: () => [timepoints, data[sensoridOut]["siaq"], 
        //   data[sensoridOut]["iaq"],    data[sensoridOut]["iaq"]],
        //  customize: (o) => {
        //    o.series[1].label = "Static IAQ";
        //    o.series[2].label = "IAQ";
        //    o.series.splice(3, 1);
        //  }
        //}
      ];
      let _spline = uPlot.paths.spline();
      let _mooSync = uPlot.sync("moo")
      const matchSyncKeys = (own, ext) => own == ext;
      let opts = {
        title: "Temp [°C]",
        id: "chart1",
        class: "my-chart",
        width: width,
        height: 200,
        cursor: {
          lock: true,
          //focus: {
          //  prox: 16
          //},
          sync: {
            key: _mooSync.key,
            setSeries: true,
            match: [matchSyncKeys, matchSyncKeys, matchSyncKeys],
          }
        },
        scales: {
          "V": {
            auto: false,
            range: [1.5, 3]
          }
        },
        series: [
          { value: "{YYYY}/{MM}/{DD} {HH}:{mm}:00" },
          {
            // initial toggled state (optional)
            show: true,

            spanGaps: false,

            // in-legend display
            label: "Sensor 1",
            stroke: "black",
	    paths: _spline,

            // series style
           // stroke: "red",
          },
          {
            label: "Sensor 2",
            show: true,
            spanGaps: false,
            stroke: "gray",
	    paths: _spline,
            value: (self, rawValue) => self.series[1].value(self, rawValue),
            fill: (self, idx) => {return self.series[1].fill},
          },
          {
            label: "Sensor O",
            show: true,
            spanGaps: true,
            stroke: "brown",
	    paths: _spline,
            value: (self, rawValue) => self.series[1].value(self, rawValue),
            fill: (self, idx) => {return self.series[1].fill},
          }
        ],
      };
      graphs.forEach((cfg) => {
        series_data = cfg.fetch();

        let resolution = cfg.resolution || 0;
        copts = {...opts};
        copts.title = cfg.title;
        copts.series.forEach((x, idx) => {
          // ignore time series
          if (idx == 0) {
            return;
          }
          x.fill = cfg.fill;
          // that's should be default but somehow isn't
          //x.stroke = "black";
          // addig "scale" prop will remove axis values on the left
          //if (cfg.title == "Bat [V]") {
          //  x.scale = "V";
          //}
        });
        copts.series[1].value = (self, rawValue) => !rawValue && "??" || rawValue.toFixed(resolution) + cfg.unit;
        cfg.customize && cfg.customize(copts);
        var uplot = new uPlot(copts, series_data, document.body);
        _mooSync.sub(uplot);
      })
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
  </script>
</body>
</html>
