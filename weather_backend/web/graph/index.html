<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="uPlot.min.css">
  <meta http-equiv="refresh" content="300" />
  <title>Weather station v0.0.1</title>
</head>

<body>

  <script src="uPlot.iife.js"></script>

  <script type="text/javascript">
    var data = {};
    var sensorid = "e09806259a66";
    var sensorid2 = "24a1603048ba";
    var sensoridOut = "ec62609d4998";

    function absolute_humidity(t, p, h) {
      if (!t || !p || !h) {
        return null;
      }
      // https://planetcalc.com/2167/
      Rw = 461.52 // J/(kgK)
      ew_t = 6.112*Math.exp((17.62*t)/(243.12+t))
      f_p = 1.0016 + (3.15E-6*p)-(0.074/p)
      A = h * f_p * ew_t
      B = (Rw * (t+ 273.15))
      return A/B
    }
    function dew_point(t, h) {
      if (!t || !h) {
        return null;
      }
      // https://en.wikipedia.org/wiki/Dew_point
      a = 17.625
      b = 243.04
      F = a*t/(b + t) + Math.log(h)
      return b*F / (a - F)
    }
    function zip(arrays) {
      // https://stackoverflow.com/questions/4856717/javascript-equivalent-of-pythons-zip-function
      return arrays[0].map(function(_,i){
        return arrays.map(function(array){return array[i]})
      });
    }
    function create_timepoints(_data) {
      // check for 
      var timepoints = new Array(_data.clock.count);
      for (i = 0; i < _data.clock.count; ++i) {
        timepoints[i] = (_data.clock.start + _data.clock.tick * i);
      }
      return timepoints;
    }
    var xmlhttp = new XMLHttpRequest();
    var url = "data.json";
    xmlhttp.onreadystatechange = function() {
      if (!(this.readyState == 4 && this.status == 200)) {
	      return;
      }
      data = JSON.parse(this.responseText);
      console.log("Data fetched");
      var augmented = [];
      var width = window.innerWidth * 0.9 || 800;
      var timepoints = create_timepoints(data);
      let default_fetch = (key) => {
      return () => [timepoints,
	      data[sensorid][key],
	      data[sensorid2][key],
	      data[sensoridOut][key]];
};
      let graphs = [
        {
          title: "Temp [°C]",
          fill: "rgba(200, 0, 0, 0.3)",
          unit: "°C",
          stroke: "red",
          fetch: default_fetch("temp"),
          resolution: 1
        },
        //{
        //  title: "Dew point [°C]",
        //  fill: "rgba(255, 128, 128, 0.3)",
        //  unit: "°C",
        //  stroke: "green",
        //  fetch: () => {
        //    dewpointer = (x) => zip([data[x]["temp"], data[x]["hum"]]).map((xx) => dew_point(xx[0], xx[1] * 0.01));
        //    return [timepoints, dewpointer(sensorid), dewpointer(sensorid2), dewpointer(sensoridOut)];
        //  },
        //  customize: (o) => { o.series[3].show = true; }
        //},
        {
          title: "Humidity [%]",
          fill: "rgba(0, 0, 255, 0.3)",
          unit: "%",
          stroke: "blue",
          fetch: default_fetch("hum")
        },
        {
          title: "Absolute Humidity [g/m³]",
          fill: "rgba(0, 128, 128, 0.3)",
          unit: "g/m³",
          stroke: "rgb(0, 255, 255)",
          fetch: () => {
	          mapper = (x) => 1000 * absolute_humidity(x[0], x[1], x[2]);
      	    humidifier = (x) => zip([data[x]["temp"], data[x]["pres"], data[x]["hum"]]).map(mapper);
	          return [timepoints, humidifier(sensorid), humidifier(sensorid2), humidifier(sensoridOut)];
	        }
        },
        {
          title: "Pressure [hPa]",
          fill: "rgba(0, 255, 255, 0.3)",
          unit: "hPa",
          stroke: "purple",
          fetch: default_fetch("pres")
        },
        {
          title: "Bat [V]",
          fill: "rgba(128, 128, 128, 0.3)",
          unit: "V",
          stroke: "gray",
          fetch: default_fetch("volt"),
          customize: (o) => {
            o.series[3].show = false;
	  }
        }
      ];
      let opts = {
        title: "Temp [°C]",
        id: "chart1",
        class: "my-chart",
        width: width,
        height: 200,
        series: [
          { value: "{YYYY}/{MM}/{DD} {HH}:{mm}:00" },
          {
            // initial toggled state (optional)
            show: true,

            spanGaps: false,

            // in-legend display
            label: "Sensor 1",

            // series style
           // stroke: "red",
          },
          {
            label: "Sensor 2",
            show: true,
            spanGaps: false,
            value: (self, rawValue) => self.series[1].value(self, rawValue),
            fill: (self, idx) => {return self.series[1].fill},
          },
          {
            label: "Sensor O",
            show: true,
            spanGaps: true,
            value: (self, rawValue) => self.series[1].value(self, rawValue),
            fill: (self, idx) => {return self.series[1].fill},
          }
        ],
      };
      graphs.forEach((cfg) => {
        series_data = cfg.fetch();

        let resolution = cfg.resolution || 0;
        opts.title = cfg.title;
        opts.series[1].fill = cfg.fill;
        opts.series[1].value = (self, rawValue) => !rawValue && "??" || rawValue.toFixed(resolution) + cfg.unit;
        cfg.customize && cfg.customize(opts);
        var uplot = new uPlot(opts, series_data, document.body);
      })
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
  </script>
</body>
</html>
